## 简述缓存雪崩
缓存雪崩，即。一大批缓存，同时失效，此时对于这一批的数据请求就全打到数据库上，查询数据多一点，可能数据库就挂了。

缓存雪崩这个名词非常形象，雪崩这两个词完美的比喻了当前的情况。之前提到的缓存击穿，是单点情况，雪崩就是多点情况。

伴随缓存雪崩的面试题，那肯定少不了缓存雪崩的解决方法。

那缓存击穿的处理解决方法能不能用于解决缓存雪崩呢？那当然可以。

所以按老规矩，我们从MySQL的角度和Redis的角度来回答这个面试题：

### 从MySQL的角度出发
无论是对很多键的并发查询（缓存雪崩），还是一次性对同一个键的很多次并发查询（缓存击穿），MySQL的解决方法都是简单粗暴：强行减少请求量。

和击穿一样，加锁。线程读数据，先看看数据有没有上锁，上锁了，等着，没上锁，获取锁后，再给数据库请求。
数据库压力肯定瞬间下来了。
![](jichuan1.png)

这个解决方法带来的问题也很好回答：用户体验是不是就会卡顿。这是必然的，牺牲用户体验，保证数据库不死机，这就是这个方式的设计出发点。

但相对缓存击穿的情形，对于缓存雪崩采取这种策略，效果并不会这么给力。原因也很简单，此时很多客户端的访问请求，不单单是基于一个键，并发量的减少不会像缓存击穿这么明显。

### 从Redis的角度出发
先回顾击穿用的一条吧：
1. 设置热点数据不过期

第二条，也很好理解，就是设置随机过期时间，避免缓存在同一时间大批失效。换句话，就是让缓存失效时间均匀一点。


### 如果我们一开始就没缓存怎么办
在项目发布伊始，数据库中存满了数据，缓存却是空的。如果此时系统上线，请求又多，那就是妥妥的雪崩。
甚至可以说，雪崩是这种情况下的必然事件。

对于这种情况下怎么处理呢？

这里得引入一个名词：灰度发布。上了班的老铁们应该不陌生，但由于可能有读者朋友还在上学，我们普及一下：

### 灰度发布
首先灰这个词是怎么来的呢？当然是由黑和白来的，互联网一般会采用新系统完全上线或者新系统没上线定义为黑和白。
所以新产品在处于没完全上线，就被定义为灰了。
我们经常听说的A/B测试就是一种灰度发布方式，即一部分用户继续用老系统A，另一部分用户用新系统B，如果用户对新系统意见不大，甚至反馈比A好，那就逐步扩大范围，慢慢把所有用户都迁移到B上来。

聊完灰度发布，相信大家瞬间对刚刚问题有了答案。如果采用灰度发布方式，进行缓存预热，一开始流量小，数据库hold住，缓存也可以多出很多数据，渐渐增加流量，缓存也不为空，就轻轻松松解决这个问题了。


### 缓存雪崩处理原则
了解了这么多，来看个面试题吧。

面试官：如果某个查询逻辑确实复杂，数据库回应很慢，redis又对这条查询没缓存的情况，这种情况引起雪崩，我们怎么处理？

此时大家一定牢记一条原则：

结合业务需求具体分析!

结合业务需求具体分析!

结合业务需求具体分析!

来解释一下面试题：
用户A发了个非常复杂的查询请求，我们后端数据库收到查询后，开始执行查询，由于查询可能涉及多表联查，花的时间不少，还在查询过程中，
此时用户B,C,D,E,F.....发了同样复杂的请求过来，由于缓存此时为空，请求毫无疑问，就打到了数据库上，要是服务器性能差点，数据库就雪崩了。
此时咱们外层看着好像Mysql收到的请求好像也不多啊...

遇到这种情况，一定具体分析业务大体需求了。
- 如果注重时效性，那就得一开始就对这些复杂查询做做缓存。
- 不注重，那就上锁，加锁，超时的请求返回错误信息等等，减少数据库压力。



## 参考
1. 《Redis设计与实现》
2. redis 源码解析
3. 后端存储实战课
